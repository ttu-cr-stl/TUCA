# Program to substract two unsigned integers between 0 and 99 as their BCD value
# By Andres Antillon
# Supported by Claude 3.5 Sonnet and OpenAI o1
#
# The operands are read from memory locations:
#   0x00    first_operand
#   0x01    second_operand
# The results will be placed in memory at:
#   0x02    result

# Register assignments first (these should be replaced first)
def Dop1 r0
def Bop1 r1
def Dop2 r2
def Bop2 r3
def Nop2 r4
def rst r15

# Memory addresses
def op1 0x00
def op2 0x01
def result 0x02

# Read the first two operands
ld op1 Dop1      
ld op2 Dop2      

# Convert Decimal to Binary
# For first operand (in Dop1)
ldi 0x0F r5         # Load mask into r5
and Dop1 r5 Bop1    # Mask to get ones digit in Bop1
shr Dop1 4 Dop1     # Shift right to get tens digit

# Multiply tens by 10 using shifts and adds
shl Dop1 3 r6         # n * 8  (shift left 3)
shl Dop1 1 r7         # n * 2  (shift left 1)
add r6 r7 Dop1        # n * 10 = (n * 8) + (n * 2)
add Dop1 Bop1 Bop1    # Add ones digit to get final binary in Bop1

# For second operand (in Dop2)
and Dop2 r5 Bop2    # Mask to get ones digit in Bop2
shr Dop2 4 Dop2       # Shift right to get tens digit

# Multiply tens by 10 using shifts and adds
shl Dop2 3 r6         # n * 8  (shift left 3)
shl Dop2 1 r7         # n * 2  (shift left 1)
add r6 r7 Dop2        # n * 10 = (n * 8) + (n * 2)
add Dop2 Bop2 Bop2    # Add ones digit to get final binary in Bop2

# Negate the second binary operand
neg Bop2 Nop2

# Add the two binary values
add Bop1 Nop2 rst

# If negative, add 100 decimal (0x64)
# Instead of 'gt', we test bit7. If (rst & 0x80) != 0 => negative => add 100
# We test bit 7 because in two's complement representation, bit 7 is the sign bit (1=negative, 0=positive)
ldi 0x80 r13
and rst r13 r14   ; if rst is negative, r14=0x80; else 0
if r14            ; skip next if r14 == 0 (i.e. if positive)
ldi 0x64 r6
if r14            ; skip next if r14 == 0 (i.e. if positive)
add rst r6 rst

# Now do the repeated subtraction loop to convert 'rst' to BCD

ldi 0x09 r9          # constant 9
ldi 0xF6 r11         # -10 decimal
ldi 0x01 r12         # +1
ldi 0x00 r8          # tens digit

sub_loop:
    gt rst r9 r10         # r10=1 if rst>9
    skipif r10            # skip next if rst>9
    jmp done_sub_loop     # if rst<=9 => exit

    add rst r11 rst       # subtract 10
    add r8 r12 r8         # increment tens
    jmp sub_loop

done_sub_loop:

# combine tens & ones into a single BCD byte
shl r8 4 r8
or r8 rst rst

# store result
st rst result

# All done
halt



